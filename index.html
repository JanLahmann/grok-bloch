<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <title>Grokking the Bloch Sphere</title>
    <!--- Link to the last version of BabylonJS --->
    <!-- script src="https://cdn.babylonjs.com/babylon.js"></script -->
    <script src="js/babylon.js"></script>
    <script src="js/babylon.gui.min.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width   : 100%;
            height  : 100%;
            margin  : 0;
            padding : 0;
        }

        #renderCanvas {
            width   : 100%;
            height  : 100%;
            touch-action: none;
        }
    </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<script>
    window.addEventListener('DOMContentLoaded', function(){

        class ComplexNum {
            constructor(real, imaginary) {
                this.real = real;
                this.imaginary = imaginary;
            }

            getReal() {
                return this.real;
            }

            getImaginary() {
                return this.imaginary;
            }

            absValue() {
                return Math.sqrt(Math.pow(this.real, 2) +
                    Math.pow(this.imaginary, 2));
            }
        }

        class QubitState {
            constructor(inclinationRadians, azimuthRadians) {
                this.inclinationRadians = inclinationRadians;
                this.azimuthRadians = azimuthRadians;
            }

            setCartesianCoords(babylonAxesVector) {
                var babylonAxisX = babylonAxesVector.x;
                var babylonAxisY = babylonAxesVector.y;
                var babylonAxisZ = babylonAxesVector.z;

                this.inclinationRadians = Math.acos(babylonAxisY);
                this.azimuthRadians = (Math.atan(babylonAxisX / -babylonAxisZ) + Math.PI * 2) % (Math.PI * 2);

                console.log("babylonAxisX: " + babylonAxisX);
                console.log("babylonAxisY: " + babylonAxisY);
                console.log("babylonAxisZ: " + babylonAxisZ);
                console.log("this.inclinationRadians: " + this.inclinationRadians);
                console.log("this.azimuthRadians: " + this.azimuthRadians);
            }

            getCartesianCoords() {
                var babylonAxisX = Math.sin(this.inclinationRadians) *
                    Math.sin(this.azimuthRadians);
                var babylonAxisY = Math.cos(this.inclinationRadians);
                var babylonAxisZ = -Math.sin(this.inclinationRadians) *
                    Math.cos(this.azimuthRadians);

                // this.inclinationRadians = Math.acos(babylonAxisY);
                // this.azimuthRadians = Math.atan(babylonAxisX / babylonAxisZ);

                return new BABYLON.Vector3(babylonAxisX, babylonAxisY, babylonAxisZ);
            }

            getProbAmplitude0() {
                var probAmpComplex = new ComplexNum(Math.cos(this.getInclinationRadians() / 2), 0);
                //console.log("probAmpComplex: " + probAmpComplex.getReal() + " " + probAmpComplex.getImaginary());
                return probAmpComplex;
            }

            getProbAmplitude1() {
                var sinHalfIncl = Math.sin(this.getInclinationRadians() / 2);
                var probAmpComplex = new ComplexNum(Math.cos(this.getAzimuthRadians()) * sinHalfIncl,
                    Math.sin(this.getAzimuthRadians()) * sinHalfIncl);
                console.log("probAmpComplex1: " + probAmpComplex.getReal() + " " + probAmpComplex.getImaginary());
                console.log("this.azimuthRadians: " + this.azimuthRadians);
                return probAmpComplex;
            }

            getProbability0() {
                return Math.pow(this.getProbAmplitude0().absValue(), 2);
            }

            getProbability1() {
                return Math.pow(this.getProbAmplitude1().absValue(), 2);
            }

            setInclinationRadians(inclinationRadians) {
                this.inclinationRadians = inclinationRadians;
            }

            getInclinationRadians() {
                return this.inclinationRadians;
            }

            setAzimuthRadians(azimuthRadians) {
                this.azimuthRadians = (azimuthRadians + Math.PI * 2) % (Math.PI * 2);
            }

            getAzimuthRadians() {
                return this.azimuthRadians % (Math.PI * 2);
            }

        }

        const fontSize = 20;

        var qubitState = new QubitState(0, 0);
        var quantumStateGrid = new BABYLON.GUI.Grid();
        var quantumStateLine = null;
        var quantumStateLineCap = null;
        var lineColor = new BABYLON.Color3(.3, .3, .3);
        var quantumStateLineColor = new BABYLON.Color3(0, 0, 1);

        var probAmplitudeTextBlock0 = new BABYLON.GUI.TextBlock();
        var probAmplitudeTextBlock1 = new BABYLON.GUI.TextBlock();
        var probabilityTextBlock0 = new BABYLON.GUI.TextBlock();
        var probabilityTextBlock1 = new BABYLON.GUI.TextBlock();

        var sphere = null;

        var complexNum = new ComplexNum(3, -4);
        console.log("complexNum.absValue() = " + complexNum.absValue());




        // get the canvas DOM element
        var canvas = document.getElementById('renderCanvas');

        // load the 3D engine
        var engine = new BABYLON.Engine(canvas, true);

        // createScene function that creates and return the scene
        var createScene = function(){
            // Create the scene space
            //engine.setHardwareScalingLevel(1 / window.devicePixelRatio);
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3( .75, .75, .75);

            // Add a camera to the scene and attach it to the canvas
            var camera = new BABYLON.ArcRotateCamera("camera1",  -Math.PI / 2.5, Math.PI / 2.5, 6, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);

            // Add lights to the scene
            var light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(-3, 7, 1), scene);

            // Add and manipulate meshes in the scene
            var myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
            sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameterX: 2.0, diameterY: 2.0, diameterZ: 2.0}, scene);
            sphere.material = myMaterial;
            sphere.position.y = 0.0;
            sphere.scaling = new BABYLON.Vector3(1.0, 1.0, 1.0);

            var equator = createEquator();
            equator.parent = sphere;
            equator.color = lineColor;

            // var ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 3, height:3}, scene)

            myMaterial.alpha = 0.4;

            //Array of points to construct Bloch X axis line
            var xAxisPoints = [
                new BABYLON.Vector3(0, 0, -1.0),
                new BABYLON.Vector3(0, 0, 1.0)
            ];

            //Array of points to construct Bloch Y axis line
            var yAxisPoints = [
                new BABYLON.Vector3(-1.0, 0, 0),
                new BABYLON.Vector3(1.0, 0, 0)
            ];

            //Array of points to construct Bloch Z axis line
            var zAxisPoints = [
                new BABYLON.Vector3(0, 1.0, 0),
                new BABYLON.Vector3(0, -1.0, 0)
            ];

            //Create lines
            var xAxisLine = BABYLON.MeshBuilder.CreateLines("xAxisLine", {points: xAxisPoints}, scene);
            var yAxisLine = BABYLON.MeshBuilder.CreateLines("yAxisLine", {points: yAxisPoints}, scene);
            var zAxisLine = BABYLON.MeshBuilder.CreateLines("zAxisLine", {points: zAxisPoints}, scene);

            xAxisLine.color = lineColor;
            yAxisLine.color = lineColor;
            zAxisLine.color = lineColor;

            xAxisLine.isPickable = false;
            yAxisLine.isPickable = false;
            zAxisLine.isPickable = false;

            xAxisLine.parent = sphere;
            yAxisLine.parent = sphere;
            zAxisLine.parent = sphere;

            // Axis labels
            var xChar = makeTextPlane("X", "black", 0.2);
            xChar.position = new BABYLON.Vector3(0, 0.1, -1.2);
            xChar.isPickable = false;

            var yChar = makeTextPlane("Y", "black", 0.2);
            yChar.position = new BABYLON.Vector3(1.2, 0, 0);
            yChar.isPickable = false;

            var zeroKet = makeTextPlane("|0>", "black", 0.2);
            zeroKet.position = new BABYLON.Vector3(0, 1.2, 0);
            zeroKet.isPickable = false;

            var oneKet = makeTextPlane("|1>", "black", 0.2);
            oneKet.position = new BABYLON.Vector3(0, -1.2, 0);
            oneKet.isPickable = false;

            var plusKet = makeTextPlane("|+>", "black", 0.2);
            plusKet.position = new BABYLON.Vector3(0, -0.1, -1.2);
            plusKet.isPickable = false;

            var minusKet = makeTextPlane("<-|", "black", 0.2);
            minusKet.position = new BABYLON.Vector3(0, 0, 1.2);
            minusKet.isPickable = false;

            //Array of points to construct quantum state line
            var qStatePoints = [
                new BABYLON.Vector3(0, 0, 0),
                new BABYLON.Vector3(0, 1, 0)
            ];

            // Buttons, panels
            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            var UiPanel = new BABYLON.GUI.StackPanel();
            UiPanel.width = "220px";
            UiPanel.fontSize = "14px";
            UiPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            UiPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            advancedTexture.addControl(UiPanel);

            // Grid labels
            var basisLabel0 = new BABYLON.GUI.TextBlock();
            basisLabel0.text = "|0>";
            basisLabel0.color = "black";
            basisLabel0.fontSize = fontSize;

            var basisLabel1 = new BABYLON.GUI.TextBlock();
            basisLabel1.text = "|1>";
            basisLabel1.color = "black";
            basisLabel1.fontSize = fontSize;

            // Grid
            //var grid = new BABYLON.GUI.Grid();
            quantumStateGrid.background = "white";
            // quantumStateGrid.adaptWidthToChildren = true;
            quantumStateGrid.width = "250px";
            quantumStateGrid.height = "60px";

            quantumStateGrid.addColumnDefinition(0.70);
            quantumStateGrid.addColumnDefinition(0.10);
            quantumStateGrid.addColumnDefinition(0.30);
            quantumStateGrid.addRowDefinition(0.50);
            quantumStateGrid.addRowDefinition(0.50);

            quantumStateGrid.addControl(basisLabel0, 0, 1);
            quantumStateGrid.addControl(basisLabel1, 1, 1);

            UiPanel.addControl(quantumStateGrid);

            // Define selection panel and groups
            var inclination = function(radians) {
                qubitState.setInclinationRadians(radians);
                updateQuantumStateLine();
            }

            var azimuth = function(radians) {
                qubitState.setAzimuthRadians(radians);
                updateQuantumStateLine();
            }

            var displayValue = function(value) {
                //return BABYLON.Tools.ToDegrees(value) | 0;
                //return value.toFixed(2);
                return (value / Math.PI).toFixed(2);
            }

            var rotateGroup = new BABYLON.GUI.SliderGroup("Spherical coordinates:", "S");
            inclinationSlider =
                rotateGroup.addSlider("Polar angle", inclination, "π radians", 0, Math.PI, 0, displayValue)
            rotateGroup.addSlider("Azimuth angle", azimuth, "π radians", 0, Math.PI * 2, 0, displayValue)

            var selectBox = new BABYLON.GUI.SelectionPanel("sp", [rotateGroup]);
            selectBox.width = 0.35;
            selectBox.height = 0.25;
            selectBox.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            selectBox.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;

            /* Change Color Scheme  */
            // selectBox.color = "blue";
            // selectBox.background = "#FFFF99";
            // selectBox.barColor = "#4F7DF2";
            // selectBox.headerColor = "blue";
            // selectBox.buttonColor = "orange";
            // selectBox.buttonBackground = "#684502";
            // selectBox.labelColor = "brown";

            advancedTexture.addControl(selectBox);
            scene.onPointerObservable.add((pointerInfo) => {
                switch (pointerInfo.type) {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                        if(pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh == sphere) {
                            console.log("Hi " + pointerInfo.pickInfo.pickedPoint);

                            qubitState.setCartesianCoords(pointerInfo.pickInfo.pickedPoint);
                            updateQuantumStateLine();
                        }
                        break;
                    // case BABYLON.PointerEventTypes.POINTERUP:
                    //         updateQuantumStateLine(pointerInfo.pickInfo.pickedPoint);
                    //     break;
                    // case BABYLON.PointerEventTypes.POINTERMOVE:
                    //         updateQuantumStateLine(pointerInfo.pickInfo.pickedPoint);
                    //     break;
                }
            });

            updateQuantumStateLine();

            return scene;

            // return the created scene
            return scene;
        }

        function createEquator() {
            var myPoints = [];
            var radius = 1;
            var deltaTheta = Math.PI / 20;
            var theta = 0;
            var Y = 0;
            for (var i = 0; i<Math.PI * 20; i++) {
                myPoints.push(new BABYLON.Vector3(radius * Math.cos(theta), Y, radius * Math.sin(theta)));
                theta += deltaTheta;
            }

            //Create lines
            var lines = BABYLON.MeshBuilder.CreateDashedLines("lines", {points: myPoints, updatable: true}, scene);
            lines.isPickable = false;
            return lines;
        }

        function updateQuantumStateLine() {
            if (quantumStateLine) quantumStateLine.dispose();
            if (quantumStateLineCap) quantumStateLineCap.dispose();

            qubitStateCartesianCoords = qubitState.getCartesianCoords();

            var qStatePoints = [
                sphere.position,
                // new BABYLON.Vector3(0, 0, 0),
                qubitStateCartesianCoords
            ];
            quantumStateLine = BABYLON.MeshBuilder.CreateLines("qStatePoints", {points: qStatePoints}, scene);

            // quantumStateLineCap = BABYLON.MeshBuilder.CreateSphere("quantumStateLineCap", {diameterX: 0.05, diameterY: 0.05, diameterZ: 0.05}, scene);
            quantumStateLineCap = BABYLON.MeshBuilder.CreateCylinder("quantumStateLineCap", {height: 0.1, diameterTop: 0.0, diameterBottom: 0.1, tessellation: 6, subdivisions: 1 }, scene);

            quantumStateLine.color = quantumStateLineColor;
            quantumStateLineCap.color = quantumStateLineColor;
            quantumStateLineCap.position = qubitState.getCartesianCoords();
            quantumStateLineCap.rotation = new BABYLON.Vector3(-qubitState.getInclinationRadians(), -qubitState.getAzimuthRadians(), 0);

            probAmplitudeTextBlock0.dispose();

            var imaginary0 = qubitState.getProbAmplitude0().getImaginary();
            var imaginary1 = qubitState.getProbAmplitude1().getImaginary();


            probAmplitudeTextBlock0.text = qubitState.getProbAmplitude0().getReal().toFixed(2) +
                (imaginary0 < 0 ? " - " : " + ") +
                Math.abs(imaginary0).toFixed(2) + "i";
            probAmplitudeTextBlock0.color = "black";
            probAmplitudeTextBlock0.fontSize = fontSize;

            probAmplitudeTextBlock1.dispose();
            probAmplitudeTextBlock1.text = qubitState.getProbAmplitude1().getReal().toFixed(2) +
                (imaginary1 < 0 ? " - " : " + ") +
                Math.abs(imaginary1).toFixed(2) + "i";
            probAmplitudeTextBlock1.color = "black";
            probAmplitudeTextBlock1.fontSize = fontSize;

            probabilityTextBlock0.dispose();
            probabilityTextBlock0.text = qubitState.getProbability0().toFixed(2);
            probabilityTextBlock0.color = "black";
            probabilityTextBlock0.fontSize = fontSize;

            probabilityTextBlock1.dispose();
            probabilityTextBlock1.text = qubitState.getProbability1().toFixed(2);
            probabilityTextBlock1.color = "black";
            probabilityTextBlock1.fontSize = fontSize;

            quantumStateGrid.addControl(probAmplitudeTextBlock0, 0, 0);
            quantumStateGrid.addControl(probAmplitudeTextBlock1, 1, 0);
            quantumStateGrid.addControl(probabilityTextBlock0, 0, 2);
            quantumStateGrid.addControl(probabilityTextBlock1, 1, 2);
        }

        function makeTextPlane(text, color, size) {
            var dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", 50, scene, true);
            dynamicTexture.hasAlpha = true;
            dynamicTexture.drawText(text, 5, 40, "bold 36px Arial", color, "transparent", true);
            var plane = new BABYLON.Mesh.CreatePlane("TextPlane", size, scene, true);
            plane.material = new BABYLON.StandardMaterial("TextPlaneMaterial", scene);
            plane.material.backFaceCulling = false;
            plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
            plane.material.diffuseTexture = dynamicTexture;
            return plane;
        };


        // call the createScene function
        var scene = createScene();

        // run the render loop
        engine.runRenderLoop(function(){
            scene.render();
        });

        // the canvas/window resize event handler
        window.addEventListener('resize', function(){
            engine.resize();
        });
    });
</script>
</body>
</html>