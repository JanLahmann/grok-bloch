<!DOCTYPE html>
<!--
  Copyright 2019 the original author or authors.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  TODO:
    - Add gate buttons and functionality
    - Use min version of babylon.js
    - Document classes
-->
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <title>v0.092 Grokking the Bloch Sphere</title>
    <!--- Link to the last version of BabylonJS --->
    <!-- script src="https://cdn.babylonjs.com/babylon.js"></script -->
    <script src="js/thirdparty/babylon.js"></script>
    <script src="js/thirdparty/babylon.gui.min.js"></script>
    <script src="js/thirdparty/math.min.js"></script>
    <script src="js/blochsphere.js"></script>
    <script src="js/gate.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width   : 100%;
            height  : 100%;
            margin  : 0;
            padding : 0;
        }

        #renderCanvas {
            width   : 100%;
            height  : 100%;
            touch-action: none;
        }
    </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<script>
    window.addEventListener('DOMContentLoaded', function(){

        const fontSize = 24;

        var blochSphere = null;

        var quantumStateGrid = new BABYLON.GUI.Grid();
        var probAmplitudeTextBlock0 = new BABYLON.GUI.TextBlock();
        var probAmplitudeTextBlock1 = new BABYLON.GUI.TextBlock();
        var probabilityTextBlock0 = new BABYLON.GUI.TextBlock();
        var probabilityTextBlock1 = new BABYLON.GUI.TextBlock();

        // get the canvas DOM element
        var canvas = document.getElementById('renderCanvas');

        // load the 3D engine
        var engine = new BABYLON.Engine(canvas, true);

        // createScene function that creates and return the scene
        var createScene = function(){
            // Create the scene space
            var scene = new BABYLON.Scene(engine);

            blochSphere = new BlochSphere("blochSphere", scene, 0, 0);

            BABYLON.SceneOptimizer.OptimizeAsync(scene);

            scene.clearColor = new BABYLON.Color3( .75, .75, .75);

            // Add a camera to the scene and attach it to the canvas
            var camera = new BABYLON.ArcRotateCamera("camera1",  -Math.PI / 2.5, Math.PI / 2.5, 6, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);

            // Add lights to the scene
            var light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(-3, 7, 1), scene);


            // Buttons, panels
            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");




            /////// Gates panel
            var leftPanel = new BABYLON.GUI.StackPanel();
            leftPanel.width = "250px";
            leftPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            leftPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            advancedTexture.addControl(leftPanel);

            var rightPanel = new BABYLON.GUI.StackPanel();
            rightPanel.width = "100px";
            rightPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            rightPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            advancedTexture.addControl(rightPanel);

            // TODO: Move these into styles
            var buttonSize = "65px";
            var paddingTop = "10px";

            var xGateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/x-gate.png");
            xGateBtn.paddingTop = paddingTop;
            xGateBtn.width = buttonSize;
            xGateBtn.height = buttonSize;
            xGateBtn.onPointerDownObservable.add(()=> {
                console.log(Gate.X);
                blochSphere.applyGate(Gate.X);
            });
            leftPanel.addControl(xGateBtn);

            var yGateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/y-gate.png");
            yGateBtn.paddingTop = paddingTop;
            yGateBtn.width = buttonSize;
            yGateBtn.height = buttonSize;
            yGateBtn.onPointerDownObservable.add(()=> {
                console.log(Gate.Y);
                blochSphere.applyGate(Gate.Y);
            });
            leftPanel.addControl(yGateBtn);

            var zGateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/z-gate.png");
            zGateBtn.paddingTop = paddingTop;
            zGateBtn.width = buttonSize;
            zGateBtn.height = buttonSize;
            zGateBtn.onPointerDownObservable.add(()=> {
                console.log(Gate.Z);
                blochSphere.applyGate(Gate.Z);
            });
            leftPanel.addControl(zGateBtn);

            var hGateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/h-gate.png");
            hGateBtn.paddingTop = paddingTop;
            hGateBtn.width = buttonSize;
            hGateBtn.height = buttonSize;
            hGateBtn.onPointerDownObservable.add(()=> {
                console.log(Gate.H);
                blochSphere.applyGate(Gate.H);
            });
            leftPanel.addControl(hGateBtn);

            var sGateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/s-gate.png");
            sGateBtn.paddingTop = paddingTop;
            sGateBtn.width = buttonSize;
            sGateBtn.height = buttonSize;
            sGateBtn.onPointerDownObservable.add(()=> {
                console.log(Gate.S);
                blochSphere.applyGate(Gate.S);
            });
            rightPanel.addControl(sGateBtn);

            var sDagGateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/s-dag-gate.png");
            sDagGateBtn.paddingTop = paddingTop;
            sDagGateBtn.width = buttonSize;
            sDagGateBtn.height = buttonSize;
            sDagGateBtn.onPointerDownObservable.add(()=> {
                console.log(Gate.St);
                blochSphere.applyGate(Gate.St);
            });
            rightPanel.addControl(sDagGateBtn);

            var tGateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/t-gate.png");
            tGateBtn.paddingTop = paddingTop;
            tGateBtn.width = buttonSize;
            tGateBtn.height = buttonSize;
            tGateBtn.onPointerDownObservable.add(()=> {
                console.log(Gate.T);
                blochSphere.applyGate(Gate.T);
            });
            rightPanel.addControl(tGateBtn);

            var tDagGateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/t-dag-gate.png");
            tDagGateBtn.paddingTop = paddingTop;
            tDagGateBtn.width = buttonSize;
            tDagGateBtn.height = buttonSize;
            tDagGateBtn.onPointerDownObservable.add(()=> {
                console.log(Gate.Tt);
                blochSphere.applyGate(Gate.Tt);
            });
            rightPanel.addControl(tDagGateBtn);

            /*
             var u1GateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/u1-gate.png");
             u1GateBtn.paddingTop = paddingTop;
             u1GateBtn.width = buttonSize;
             u1GateBtn.height = buttonSize;
             u1GateBtn.onPointerDownObservable.add(()=> {
                 //if (idleRange) scene.beginAnimation(skeleton, idleRange.from, idleRange.to, true);
             });
             leftPanel.addControl(u1GateBtn);

             var u3GateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/u3-gate.png");
             u3GateBtn.paddingTop = paddingTop;
             u3GateBtn.width = buttonSize;
             u3GateBtn.height = buttonSize;
             u3GateBtn.onPointerDownObservable.add(()=> {
                 //if (idleRange) scene.beginAnimation(skeleton, idleRange.from, idleRange.to, true);
             });
             leftPanel.addControl(u3GateBtn);
             */

            /*
            var u2GateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/u2-gate.png");
            u2GateBtn.paddingTop = paddingTop;
            u2GateBtn.width = buttonSize;
            u2GateBtn.height = buttonSize;
            u2GateBtn.onPointerDownObservable.add(()=> {
                //if (idleRange) scene.beginAnimation(skeleton, idleRange.from, idleRange.to, true);
            });
            rightPanel.addControl(u2GateBtn);

            var zeroStateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/zero-state.png");
            zeroStateBtn.paddingTop = paddingTop;
            zeroStateBtn.width = buttonSize;
            zeroStateBtn.height = buttonSize;
            zeroStateBtn.onPointerDownObservable.add(()=> {
                //if (idleRange) scene.beginAnimation(skeleton, idleRange.from, idleRange.to, true);
            });
            rightPanel.addControl(zeroStateBtn);
            */

            /////// END Gates panel





            var UiPanel = new BABYLON.GUI.StackPanel();
            UiPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            UiPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            advancedTexture.addControl(UiPanel);

            // Grid labels
            var basisLabel0 = new BABYLON.GUI.TextBlock();
            basisLabel0.text = "|0>";
            basisLabel0.color = "black";
            basisLabel0.fontSize = fontSize;

            var basisLabel1 = new BABYLON.GUI.TextBlock();
            basisLabel1.text = "|1>";
            basisLabel1.color = "black";
            basisLabel1.fontSize = fontSize;

            // Grid
            //var grid = new BABYLON.GUI.Grid();
            quantumStateGrid.background = "white";
            // quantumStateGrid.adaptWidthToChildren = true;
            quantumStateGrid.width = "300px";
            quantumStateGrid.height = "80px";

            quantumStateGrid.addColumnDefinition(0.70);
            quantumStateGrid.addColumnDefinition(0.10);
            quantumStateGrid.addColumnDefinition(0.30);
            quantumStateGrid.addRowDefinition(0.50);
            quantumStateGrid.addRowDefinition(0.50);

            quantumStateGrid.addControl(basisLabel0, 0, 1);
            quantumStateGrid.addControl(basisLabel1, 1, 1);

            UiPanel.addControl(quantumStateGrid);

            // Define selection panel and groups
            var inclination = function(radians) {
                blochSphere.setInclinationRadians(radians);
                //blochSphere.updateQuantumStateLine();
                updateQuantumStateDisplay();
            }

            var azimuth = function(radians) {
                blochSphere.setAzimuthRadians(radians);
                //blochSphere.updateQuantumStateLine();
                updateQuantumStateDisplay();
            }

            var displayValue = function(value) {
                //return BABYLON.Tools.ToDegrees(value) | 0;
                //return value.toFixed(2);
                return (value / Math.PI).toFixed(2);
            }

            var rotateGroup = new BABYLON.GUI.SliderGroup("Spherical coordinates:", "S");
            rotateGroup.addSlider("Polar angle", inclination, "π radians", 0, Math.PI, 0, displayValue)
            rotateGroup.addSlider("Azimuth angle", azimuth, "π radians", 0, Math.PI * 2, 0, displayValue)

            var selectBox = new BABYLON.GUI.SelectionPanel("sp", [rotateGroup]);
            selectBox.width = 0.35;
            selectBox.height = 0.25;
            selectBox.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            selectBox.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            // selectBox.fontFamily = "times new roman";
            // selectBox.fontSize = "36pt";

            // selectBox.color = "blue";
            // selectBox.background = "#FFFF99";
            // selectBox.barColor = "#4F7DF2";
            // selectBox.headerColor = "blue";
            // selectBox.buttonColor = "orange";
            // selectBox.buttonBackground = "#684502";
            // selectBox.labelColor = "brown";

            advancedTexture.addControl(selectBox);
            scene.onPointerObservable.add((pointerInfo) => {
                switch (pointerInfo.type) {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                        // TODO: Find out how to identify that sphere was picked
                        //if(pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh == sphere) {
                        if(pointerInfo.pickInfo.hit) {
                            console.log("pickedPoint: " + pointerInfo.pickInfo.pickedPoint);

                            blochSphere.setCartesianCoords(pointerInfo.pickInfo.pickedPoint);
                            //blochSphere.updateQuantumStateLine();
                            updateQuantumStateDisplay();
                        }
                        break;
                }
            });

            //blochSphere.updateQuantumStateLine();
            updateQuantumStateDisplay();

            // return the created scene
            return scene;
        }

        function updateQuantumStateDisplay() {
            probAmplitudeTextBlock0.dispose();

            var imaginary0 = blochSphere.getProbAmplitude0().im;
            var imaginary1 = blochSphere.getProbAmplitude1().im;


            probAmplitudeTextBlock0.text = blochSphere.getProbAmplitude0().re.toFixed(2) +
                (imaginary0 < 0 ? " - " : " + ") +
                Math.abs(imaginary0).toFixed(2) + "i";
            probAmplitudeTextBlock0.color = "black";
            probAmplitudeTextBlock0.fontSize = fontSize;

            probAmplitudeTextBlock1.dispose();
            probAmplitudeTextBlock1.text = blochSphere.getProbAmplitude1().re.toFixed(2) +
                (imaginary1 < 0 ? " - " : " + ") +
                Math.abs(imaginary1).toFixed(2) + "i";
            probAmplitudeTextBlock1.color = "black";
            probAmplitudeTextBlock1.fontSize = fontSize;

            probabilityTextBlock0.dispose();
            probabilityTextBlock0.text = blochSphere.getProbability0().toFixed(2);
            probabilityTextBlock0.color = "black";
            probabilityTextBlock0.fontSize = fontSize;

            probabilityTextBlock1.dispose();
            probabilityTextBlock1.text = blochSphere.getProbability1().toFixed(2);
            probabilityTextBlock1.color = "black";
            probabilityTextBlock1.fontSize = fontSize;

            quantumStateGrid.addControl(probAmplitudeTextBlock0, 0, 0);
            quantumStateGrid.addControl(probAmplitudeTextBlock1, 1, 0);
            quantumStateGrid.addControl(probabilityTextBlock0, 0, 2);
            quantumStateGrid.addControl(probabilityTextBlock1, 1, 2);
        }

        // call the createScene function
        var scene = createScene();

        // run the render loop
        engine.runRenderLoop(function(){
            scene.render();
        });

        // the canvas/window resize event handler
        window.addEventListener('resize', function(){
            engine.resize();
        });
    });
</script>
</body>
</html>