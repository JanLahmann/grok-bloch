<!DOCTYPE html>
<!--
  Copyright 2019 the original author or authors.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  TODO:
    [] Add gate buttons and functionality
    [] Use min version of babylon.js
    [] Document classes
    [] Fix meta element so image will load into GitBook links
    [] Improve formatting of Pi rotations by justifying text instead of using spaces
-->
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <!--meta property="twitter:image" content="https://javafxpert.github.io/grok-bloch/images/bloch-sphere.png"-->
    <title>v0.092 Grokking the Bloch Sphere</title>
    <!--- Link to the last version of BabylonJS --->
    <!-- script src="https://cdn.babylonjs.com/babylon.js"></script -->
    <script src="js/thirdparty/babylon.js"></script>
    <script src="js/thirdparty/babylon.gui.min.js"></script>
    <script src="js/thirdparty/math.min.js"></script>
    <script src="js/blochsphere.js"></script>
    <script src="js/gate.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width   : 100%;
            height  : 100%;
            margin  : 0;
            padding : 0;
        }

        #renderCanvas {
            width   : 100%;
            height  : 100%;
            touch-action: none;
        }
    </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<script>
    window.addEventListener('DOMContentLoaded', function(){

        const fontSize = 28;

        var blochSphere = null;

        var quantumStateDiracGrid = new BABYLON.GUI.Grid();

        var quantumStateGrid = new BABYLON.GUI.Grid();
        var probAmplitudeTextBlock0 = new BABYLON.GUI.TextBlock();
        var probAmplitudeTextBlock1 = new BABYLON.GUI.TextBlock();
        var probabilityTextBlock0 = new BABYLON.GUI.TextBlock();
        var probabilityTextBlock1 = new BABYLON.GUI.TextBlock();
        var azimuthRadiansTextBlock = new BABYLON.GUI.TextBlock();

        // get the canvas DOM element
        var canvas = document.getElementById('renderCanvas');

        // load the 3D engine
        var engine = new BABYLON.Engine(canvas, true);

        // createScene function that creates and return the scene
        var createScene = function(){
            // Create the scene space
            var scene = new BABYLON.Scene(engine);

            blochSphere = new BlochSphere("blochSphere", scene, 0, 0);

            BABYLON.SceneOptimizer.OptimizeAsync(scene);

            scene.clearColor = new BABYLON.Color3( .75, .75, .75);

            // Add a camera to the scene and attach it to the canvas
            var camera = new BABYLON.ArcRotateCamera("camera1",  -Math.PI / 2.5, Math.PI / 2.5, 6, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);

            // Add lights to the scene
            var light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(-3, 7, 1), scene);


            // Buttons, panels
            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");




            /////// Gates panel
            var leftPanel = new BABYLON.GUI.StackPanel();
            leftPanel.width = "250px";
            leftPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            leftPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            advancedTexture.addControl(leftPanel);

            var rightPanel = new BABYLON.GUI.StackPanel();
            rightPanel.width = "100px";
            rightPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            rightPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            advancedTexture.addControl(rightPanel);

            // TODO: Move these into styles
            var buttonSize = "65px";
            var paddingTop = "10px";

            var xGateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/x-gate.png");
            xGateBtn.paddingTop = paddingTop;
            xGateBtn.width = buttonSize;
            xGateBtn.height = buttonSize;
            xGateBtn.onPointerDownObservable.add(()=> {
                console.log(Gate.X);
                blochSphere.applyGate(Gate.X);
                updateQuantumStateDisplay();
            });
            leftPanel.addControl(xGateBtn);

            var yGateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/y-gate.png");
            yGateBtn.paddingTop = paddingTop;
            yGateBtn.width = buttonSize;
            yGateBtn.height = buttonSize;
            yGateBtn.onPointerDownObservable.add(()=> {
                console.log(Gate.Y);
                blochSphere.applyGate(Gate.Y);
                updateQuantumStateDisplay();
            });
            leftPanel.addControl(yGateBtn);

            var zGateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/z-gate.png");
            zGateBtn.paddingTop = paddingTop;
            zGateBtn.width = buttonSize;
            zGateBtn.height = buttonSize;
            zGateBtn.onPointerDownObservable.add(()=> {
                console.log(Gate.Z);
                blochSphere.applyGate(Gate.Z);
                updateQuantumStateDisplay();
            });
            leftPanel.addControl(zGateBtn);

            var hGateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/h-gate.png");
            hGateBtn.paddingTop = paddingTop;
            hGateBtn.width = buttonSize;
            hGateBtn.height = buttonSize;
            hGateBtn.onPointerDownObservable.add(()=> {
                console.log(Gate.H);
                blochSphere.applyGate(Gate.H);
                updateQuantumStateDisplay();
            });
            leftPanel.addControl(hGateBtn);

            var u1GateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/u1-gate.png");
            u1GateBtn.paddingTop = paddingTop;
            u1GateBtn.width = buttonSize;
            u1GateBtn.height = buttonSize;
            u1GateBtn.onPointerDownObservable.add(()=> {
                //if (idleRange) scene.beginAnimation(skeleton, idleRange.from, idleRange.to, true);
            });
            leftPanel.addControl(u1GateBtn);

            var u3GateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/u3-gate.png");
            u3GateBtn.paddingTop = paddingTop;
            u3GateBtn.width = buttonSize;
            u3GateBtn.height = buttonSize;
            u3GateBtn.onPointerDownObservable.add(()=> {
                //if (idleRange) scene.beginAnimation(skeleton, idleRange.from, idleRange.to, true);
            });
            leftPanel.addControl(u3GateBtn);

            var sGateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/s-gate.png");
            sGateBtn.paddingTop = paddingTop;
            sGateBtn.width = buttonSize;
            sGateBtn.height = buttonSize;
            sGateBtn.onPointerDownObservable.add(()=> {
                console.log(Gate.S);
                blochSphere.applyGate(Gate.S);
                updateQuantumStateDisplay();
            });
            rightPanel.addControl(sGateBtn);

            var sDagGateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/s-dag-gate.png");
            sDagGateBtn.paddingTop = paddingTop;
            sDagGateBtn.width = buttonSize;
            sDagGateBtn.height = buttonSize;
            sDagGateBtn.onPointerDownObservable.add(()=> {
                console.log(Gate.St);
                blochSphere.applyGate(Gate.St);
                updateQuantumStateDisplay();
            });
            rightPanel.addControl(sDagGateBtn);

            var tGateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/t-gate.png");
            tGateBtn.paddingTop = paddingTop;
            tGateBtn.width = buttonSize;
            tGateBtn.height = buttonSize;
            tGateBtn.onPointerDownObservable.add(()=> {
                console.log(Gate.T);
                blochSphere.applyGate(Gate.T);
                updateQuantumStateDisplay();
            });
            rightPanel.addControl(tGateBtn);

            var tDagGateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/t-dag-gate.png");
            tDagGateBtn.paddingTop = paddingTop;
            tDagGateBtn.width = buttonSize;
            tDagGateBtn.height = buttonSize;
            tDagGateBtn.onPointerDownObservable.add(()=> {
                console.log(Gate.Tt);
                blochSphere.applyGate(Gate.Tt);
                updateQuantumStateDisplay();
            });
            rightPanel.addControl(tDagGateBtn);

            var u2GateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/u2-gate.png");
            u2GateBtn.paddingTop = paddingTop;
            u2GateBtn.width = buttonSize;
            u2GateBtn.height = buttonSize;
            u2GateBtn.onPointerDownObservable.add(()=> {
                //if (idleRange) scene.beginAnimation(skeleton, idleRange.from, idleRange.to, true);
            });
            rightPanel.addControl(u2GateBtn);

            var zeroStateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("but", "textures/zero-state.png");
            zeroStateBtn.paddingTop = paddingTop;
            zeroStateBtn.width = buttonSize;
            zeroStateBtn.height = buttonSize;
            zeroStateBtn.onPointerDownObservable.add(()=> {
                blochSphere.setProbAmplitudes(math.complex(1, 0), math.complex(0, 0));
                updateQuantumStateDisplay();
            });
            rightPanel.addControl(zeroStateBtn);

            /////// END Gates panel


            /////// Top panel (State in Dirac notation)
            // \vert \psi \rangle = \sqrt{ 0.80} \vert 0 \rangle + (\sqrt{0.20}) e^{i 0.25\pi} \vert 1 \rangle
            // \vert \psi \rangle = \sqrt{ 0.80} \vert 0 \rangle + (\sqrt{0.20}) e^{i 0.25\pi} \vert 1 \rangle

            var qubitStateDiracImagePanel = new BABYLON.GUI.StackPanel();
            qubitStateDiracImagePanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            qubitStateDiracImagePanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            qubitStateDiracImagePanel.height = "546px";
            qubitStateDiracImagePanel.paddingTop = "10px";
            advancedTexture.addControl(qubitStateDiracImagePanel);

            var qubitStateDiracImage = new BABYLON.GUI.Image("but", "images/qubit-state-dirac.png");
            qubitStateDiracImage.width = "546px";
            qubitStateDiracImage.height = "48px";
            qubitStateDiracImagePanel.addControl(qubitStateDiracImage);

            var qubitStateDiracTextPanel = new BABYLON.GUI.StackPanel();
            qubitStateDiracTextPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            qubitStateDiracTextPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            qubitStateDiracTextPanel.height = "546px";
            qubitStateDiracTextPanel.paddingTop = "10px";
            advancedTexture.addControl(qubitStateDiracTextPanel);

            var qubitStateDiracTextBlock = new BABYLON.GUI.TextBlock();
            qubitStateDiracTextBlock.text = "Dirac notation will go here";
            qubitStateDiracTextBlock.color = "black";
            qubitStateDiracTextBlock.fontSize = fontSize;

            // qubitStateDiracPanel.width = "728px";
            // qubitStateDiracPanel.height = "163px";
            // qubitStateDiracPanel.
            //
            /////// END Top panel


            /////// Bottom panel
            var UiPanel = new BABYLON.GUI.StackPanel();
            UiPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            UiPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            advancedTexture.addControl(UiPanel);

            // Grid labels
            var basisLabel0 = new BABYLON.GUI.TextBlock();
            basisLabel0.text = "|0>";
            basisLabel0.color = "black";
            basisLabel0.fontSize = fontSize;

            var basisLabel1 = new BABYLON.GUI.TextBlock();
            basisLabel1.text = "|1>";
            basisLabel1.color = "black";
            basisLabel1.fontSize = fontSize;


            //// Dirac notation grid
            quantumStateDiracGrid.width = "546px";
            quantumStateDiracGrid.height = "48px";

            quantumStateDiracGrid.addRowDefinition(0.4);
            quantumStateDiracGrid.addRowDefinition(0.6);
            quantumStateDiracGrid.addColumnDefinition(118, true);
            quantumStateDiracGrid.addColumnDefinition(79, true);
            quantumStateDiracGrid.addColumnDefinition(125, true);
            quantumStateDiracGrid.addColumnDefinition(66, true);
            quantumStateDiracGrid.addColumnDefinition(46, true);
            quantumStateDiracGrid.addColumnDefinition(59, true);

            qubitStateDiracTextPanel.addControl(quantumStateDiracGrid);
            //// END Dirac notation grid


            // Grid
            //var grid = new BABYLON.GUI.Grid();
            // quantumStateGrid.background = "white";
            // quantumStateGrid.adaptWidthToChildren = true;
            quantumStateGrid.width = "300px";
            quantumStateGrid.height = "80px";

            quantumStateGrid.addColumnDefinition(0.70);
            quantumStateGrid.addColumnDefinition(0.10);
            quantumStateGrid.addColumnDefinition(0.30);
            quantumStateGrid.addRowDefinition(0.50);
            quantumStateGrid.addRowDefinition(0.50);

            // quantumStateGrid.addControl(basisLabel0, 0, 1);
            // quantumStateGrid.addControl(basisLabel1, 1, 1);

            UiPanel.addControl(quantumStateGrid);
            /////// END Bottom panel



            /////// Control panel
            // Define selection panel and groups
            var inclination = function(radians) {
                blochSphere.setInclinationRadians(radians);
                blochSphere.resetGlobalPhase();
                blochSphere.updateQuantumStateLine();
                updateQuantumStateDisplay();
            }

            var azimuth = function(radians) {
                blochSphere.setAzimuthRadians(radians);
                blochSphere.resetGlobalPhase();
                blochSphere.updateQuantumStateLine();
                    updateQuantumStateDisplay();
            }

            var displayValue = function(value) {
                //return BABYLON.Tools.ToDegrees(value) | 0;
                //return value.toFixed(2);
                return (value / Math.PI).toFixed(2);
            }

            var rotateGroup = new BABYLON.GUI.SliderGroup("Spherical coordinates:", "S");
            rotateGroup.addSlider("Polar angle", inclination, "π radians", 0, Math.PI, 0, displayValue)
            rotateGroup.addSlider("Azimuth angle", azimuth, "π radians", 0, Math.PI * 2, 0, displayValue)

            var selectBox = new BABYLON.GUI.SelectionPanel("sp", [rotateGroup]);
            selectBox.width = 0.35;
            selectBox.height = 0.25;
            selectBox.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            selectBox.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;

            advancedTexture.addControl(selectBox);
            /////// END Control panel


            scene.onPointerObservable.add((pointerInfo) => {
                switch (pointerInfo.type) {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                        // TODO: Find out how to identify that sphere was picked
                        //if(pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh == sphere) {
                        if(pointerInfo.pickInfo.hit) {
                            console.log("pickedPoint: " + pointerInfo.pickInfo.pickedPoint);

                            blochSphere.setCartesianCoords(pointerInfo.pickInfo.pickedPoint);
                            //blochSphere.updateQuantumStateLine();
                            updateQuantumStateDisplay();
                        }
                        break;
                }
            });

            //blochSphere.updateQuantumStateLine();
            updateQuantumStateDisplay();

            // return the created scene
            return scene;
        }

        function updateQuantumStateDisplay() {
            blochSphere.resetGlobalPhase();
            probAmplitudeTextBlock0.dispose();

            var imaginary0 = blochSphere.getProbAmplitude0().im;
            var imaginary1 = blochSphere.getProbAmplitude1().im;


            probAmplitudeTextBlock0.text = blochSphere.getProbAmplitude0().re.toFixed(2); // +
                // (imaginary0 < 0 ? " - " : " + ") +
                // Math.abs(imaginary0).toFixed(2) + "i";
            probAmplitudeTextBlock0.color = "black";
            probAmplitudeTextBlock0.fontSize = fontSize;

            probAmplitudeTextBlock1.dispose();
            probAmplitudeTextBlock1.text = blochSphere.getProbAmplitude1().re.toFixed(2) +
                (imaginary1 < 0 ? " - " : " + ") +
                Math.abs(imaginary1).toFixed(2) + "i";
            probAmplitudeTextBlock1.color = "black";
            probAmplitudeTextBlock1.fontSize = fontSize;

            probabilityTextBlock0.dispose();
            probabilityTextBlock0.text = blochSphere.getProbability0().toFixed(2);
            probabilityTextBlock0.color = "black";
            probabilityTextBlock0.fontSize = fontSize;

            probabilityTextBlock1.dispose();
            probabilityTextBlock1.text = blochSphere.getProbability1().toFixed(2);
            probabilityTextBlock1.color = "black";
            probabilityTextBlock1.fontSize = fontSize;

            azimuthRadiansTextBlock.dispose();
            //azimuthRadiansTextBlock.text = (blochSphere.getAzimuthRadians() / Math.PI).toFixed(2) + "π";
            azimuthRadiansTextBlock.text = azimuthRadiansToPiRadians(blochSphere.getAzimuthRadians());
            azimuthRadiansTextBlock.color = "black";
            azimuthRadiansTextBlock.fontSize = fontSize * 0.80;
            azimuthRadiansTextBlock.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;

            quantumStateGrid.addControl(probAmplitudeTextBlock0, 0, 0);
            quantumStateGrid.addControl(probAmplitudeTextBlock1, 1, 0);
            //quantumStateGrid.addControl(probabilityTextBlock0, 0, 2);
            //quantumStateGrid.addControl(probabilityTextBlock1, 1, 2);


            ////// Update Dirac notation
            quantumStateDiracGrid.addControl(probabilityTextBlock0, 1, 1)
            quantumStateDiracGrid.addControl(probabilityTextBlock1, 1, 3)
            quantumStateDiracGrid.addControl(azimuthRadiansTextBlock, 0, 5)
            ////// END Update Dirac notation
        }

        function azimuthRadiansToPiRadians(radians) {
            var piRadians = (radians / Math.PI).toFixed(2)
            var piRadiansStr = piRadians + "π";
            if (piRadiansStr === "0.00π" || piRadiansStr === "2.00π") {
                piRadiansStr = "0      ";
            }
            else if (piRadiansStr === "0.13π") {
                piRadiansStr = "π/8    ";
            }
            else if (piRadiansStr === "0.17π") {
                piRadiansStr = "π/6    ";
            }
            else if (piRadiansStr === "0.25π") {
                piRadiansStr = "π/4    ";
            }
            else if (piRadiansStr === "0.33π") {
                piRadiansStr = "π/3    ";
            }
            else if (piRadiansStr === "0.50π") {
                piRadiansStr = "π/2    ";
            }
            else if (piRadiansStr === "0.67π") {
                piRadiansStr = "2π/3 ";
            }
            else if (piRadiansStr === "0.75π") {
                piRadiansStr = "3π/4 ";
            }
            else if (piRadiansStr === "0.83π") {
                piRadiansStr = "5π/6 ";
            }
            else if (piRadiansStr === "0.88π") {
                piRadiansStr = "7π/8 ";
            }
            else if (piRadiansStr === "1.00π") {
                piRadiansStr = "π      ";
            }
            else if (piRadiansStr === "1.13π") {
                piRadiansStr = "9π/8 ";
            }
            else if (piRadiansStr === "1.17π") {
                piRadiansStr = "7π/6 ";
            }
            else if (piRadiansStr === "1.25π") {
                piRadiansStr = "5π/4 ";
            }
            else if (piRadiansStr === "1.33π") {
                piRadiansStr = "4π/3 ";
            }
            else if (piRadiansStr === "1.50π") {
                piRadiansStr = "3π/2 ";
            }
            else if (piRadiansStr === "1.67π") {
                piRadiansStr = "5π/3 ";
            }
            else if (piRadiansStr === "1.75π") {
                piRadiansStr = "7π/4 ";
            }
            else if (piRadiansStr === "1.83π") {
                piRadiansStr = "11π/6";
            }
            else if (piRadiansStr === "1.88π") {
                piRadiansStr = "15π/8";
            }
            return piRadiansStr;
        }

        // call the createScene function
        var scene = createScene();

        // run the render loop
        engine.runRenderLoop(function(){
            scene.render();
        });

        // the canvas/window resize event handler
        window.addEventListener('resize', function(){
            engine.resize();
        });
    });
</script>
</body>
</html>